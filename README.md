# 오픈소스 팀 프로젝트

# 디렉토리 구조
- (bin) : 최종 실행파일
- (build) : 오브젝트 파일
- (include) : 헤더 파일
	- config.h
	- include.h
	- command_func.h
	- custom_command.h
	- signal_func.h
- (src) : 소스 파일
	- command_func.c
	- custom_command.c
	- signal_func.c
	- main.c
- Makefile : 빌드 자동화 파일
- LICENSE : MIT 라이센스 파일
- README : 사용방법

---

# 구현된 로직
- 공통 로직
```bash
[공통 로직]
1. 표준입력으로부터 한줄을 입력받아 엔터로 값을 받아서 저장한다.
2. 입력받은 문자열에서 개행문자(\n)를 제거한다.
3. 해당 문자열을 공백을 기준으로 문자들을 분리해서 토큰배열으로 저장한뒤 목록의 끝은 NULL로 지정한다. (이후 다른 함수에서 해당 명령들을 편리하게 사용하기 위함)
입력(ls -al | wc -l) -> 저장 {ls, -al, |, wc, -l, NULL} 처럼 분리해서 저장
   
# execvp함수 같은 경우에는 NULL을 기준으로 문자열 배열을 구분해서 실행한다.
# 내가 구현한 custom_command 함수의 경우에도 동일하게 문자를 받아 처리하고 지정된 명령 (ls, pwd, cd, mkdir, rmdir, ln, cp, rm, mv, cat, grep) 을 제외한 나머지 명령은 execvp를 통해 실행되게 하기 위함입니다.
```

1. "exit"를 치면 프로그램을 끝내도록 프로그램을 수정하시오. 
```bash
1. 위 명령어에서 분리한 argv[0]번째 명령이 exit이면 해당 쉘을 종료합니다.
   
# 예 argv{exit, NULL} argv[0] = exit임
```

2. csh, bash 등에서처럼 쉘 명령의 마지막에 ‘&’을 입력하면 백그라운드로 실행되도록 프로그램을 수정하시오.  
```bash
1. 입력에서 명령어를 분리한뒤 맨 뒤에 & 기호가 있는지 확인한뒤
2. 있으면 background 플레그를 1로 지정하고 &기호를 삭제하고 해당자리의 값을 NULL로 지정해 문자 배열의 끝을 줄인다.
3. 이후 실행되는 함수에서 background가 1인 경우에는 자식 프로세스의 종료를 기다리지 않고 바로 해당 함수를 종료한다 (백그라운드 프로세스는 종료되지 않음 작업 수행 완료 후 종료)
4. 단 위 과정에서 자식 프로세스를 종료하지 않고 나오게 되면 좀비 프로세스로 남을 수 있는데 이를 해결하기 위해 signal(SIGCHLD, SIG_IGN);를 사용하였다
   
# 설명 signal(SIGCHLD, SIG_IGN)
부모 쉘이 `SIGCHLD`를 무시하도록 설정되면, 유닉스 커널은 부모 쉘이 대기(wait)를 원하지 않는 것으로 간주하고, 자식 프로세스가 종료되는 즉시 커널 스스로 자식의 종료 상태를 수거하고 자원을 정리해 줍니다.
```

3. csh, bash 등에서처럼 인터럽트키 (SIGINT: Ctrl-C, SIGQUIT: Ctrl-Z) 가 동작하도록 프로그램을 수정하시오. 
```bash
1. 일반적인 메인 쉘에서는 exit와 Ctrl-Z를 통해서만 종료가 가능하도록 되어있다.
2. 이후 명령어를 수행할때는 Ctrl-C와 Ctrl-\등을 사용할 수 있게 변경하여 명령어 수행도중 종료 가능하게 작성하였습니다.
```

4. 파일 재지향 (>, <) 및 파이프(|) 기능이 가능하도록 프로그램을 수정하시오. 
```bash
# 파일 재지향
1. 파일 재지향 같은 경우에는 토큰배열에서 '>' 를 발견하면 '>' 를 기준으로 오른쪽에 있는 값으로 파일을 불러와서(없는 경우 새로 만듦) 현재 프로세스의 표준 출력을 해당 파일 디스크립터(기술자)로 지정한다.
2. 이후 > 왼쪽 명령을 수행한 결과를 표준 출력으로 내보내게 되면 파일에 저장되는 것이다.
3. '<' 도 유사한 로직이다 '<' 경우에는 우측의 파일을 읽어서 해당 파일 디스크립터를 현재 프로세스의 표준 입력으로 변경한뒤 명령어를 실행하게 되면 현재프로세스는 해당 소스에서 읽어 명령을 처리한다.
   
# 파이프 (재귀로 구현해보려다가 존나 시발 복잡해서 포기하고 반복문으로 변경함)
1. 토큰배열에서 | 를 기준으로 명령어를 나눈다.
2. 세부적으로는 명령어를 저장할 명령어 배열 포인터를 만든다.
3. 해당 명령어 배열포인터[0]번에 기존 토큰배열[0]번 주소를 넣는다.
4. 이후 반복문을 통해서 | 가 나오면 해당 자리의 |를 NULL로 대체한다.
5. NULL로 대채한 다음자리의 값은 명령어기 때문에 해당 토큰배열[i+1]에 해당하는 값을
6. 명령어배열[1]에 토큰배열[i+1]을 저장한다.
7. 이후 토큰배열 전부를 순환한뒤 명령어 개수를 반환하면서 종료한다.
8. 명령어 배열을 외부에서 주입하는 방식이라서 ***삼중 포인터(2차원 배열)가 사용되었습니다.
	{ls, -al, |, wc, -l, NULL} 을 해당 함수를 통해 분리되면
	- ls -al NULL wc -l
	- 명령어배열[0] = {ls, -al, NULL}
	- 명령어배열[1] = {wc, -l, NULL}
	와 같은 방식으로 명령어들이 분리되게 된다.
9. 반복문을 순회하면서 char **current_cmd = cmd_argv[i]; 방식으로 다시 1차원 배열로 할당한다.
10. 파이프를 읽기와 쓰기부분을 분리해서 생성한다.
11. 왼쪽 명령부터 수행해서 해당 파이프로 출력을 진행한다.
12. 출력을 진행한 뒤 파이프의 읽기 부분을 변수에 저장한다.(다음 파이프나 프로세스에서 사용)
13. 다음명령에서는 마지막 명령이면 파이프를 생성하지 않고 현재 프로세스의 읽기 부분을 파이프의 읽기 부분으로 변경한뒤 명령을 처리한뒤 표준 출력으로 터미널에 출력한다.
```


---

# 비구현된 로직

1. ls, pwd, cd, mkdir, rmdir, ln, cp, rm, mv, cat, grep 명령을 팀원이 공평하게 나누어 구현하시오.
``` bash
# custom_command.c 의 함수에 추가만 하면됨 전달되는 argv인자에는 이전에 파이프등에서 분리된 명령어배열[0]번의 명령어토큰배열이 전달되기 때문에 해당 argv인자에서 NULL이 나올때까지 이전 명령어들을 처리하면됨
# 즉 {ls -l | wc -l}이라고 처음 입력했다고 하더라도 해당 함수로 전달되는 건 {ls, -l, NULL} 이기 때문에 해당 값을 처리하게 끔 수정하면 된다.

# [주의]
# 입력과 출력을 표준입력과 표준출력으로 처리되게 해야한다.
# 에러또한 표준에러로 출력하게 해야한다.
# 그래야 위 재지향이나 파이프에서 변경없이 사용할 수 있음
```
